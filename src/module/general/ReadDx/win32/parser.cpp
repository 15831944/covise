/* This file is part of COVISE.

   You can use it under the terms of the GNU Lesser General Public License
   version 2.1 or later, see lgpl-2.1.txt.

 * License: LGPL 2+ */

#define YY_Parser_h_included
#define YY_USE_CLASS

/*  A Bison++ parser, made from dxreader.yacc  */

/* with Bison++ version bison++ Version 1.21.9-1, adapted from GNU bison by coetmeur@icdc.fr
Maintained by Magnus Ekdahl <magnus@debian.org>
  */

#define YY_USE_CLASS

#line 1 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"
/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Bob Corbett and Richard Stallman

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 1, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  

   As a special exception, when this file is copied by Bison++ into a
   Bison++ output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison, and has been in Bison++ since 1.21.9.  

*/

/* HEADER SECTION */
#if defined(_MSDOS) || defined(MSDOS) || defined(__MSDOS__)
#define __MSDOS_AND_ALIKE
#endif

#if defined(_WINDOWS) && defined(_MSC_VER)
#define __HAVE_NO_ALLOCA
#define __MSDOS_AND_ALIKE
#endif

#ifdef WIN32
#define __HAVE_NO_ALLOCA
#define __MSDOS_AND_ALIKE
#endif

#ifndef alloca
#if defined(__GNUC__)
#define alloca __builtin_alloca

#elif(!defined(__STDC__) && defined(sparc)) || defined(__sparc__) || defined(__sparc) || defined(__sgi)
#include <alloca.h>

#elif defined(__MSDOS_AND_ALIKE)
#include <malloc.h>
#ifndef __TURBOC__
/* MS C runtime lib */
#define alloca _alloca
#endif

#elif defined(_AIX)
/* pragma must be put before any C/C++ instruction !! */
#pragma alloca
#include <malloc.h>

#elif defined(__hpux)
#ifdef __cplusplus
extern "C" {
void *alloca(unsigned int);
};
#else /* not __cplusplus */
void *alloca();
#endif /* not __cplusplus */

#endif /* not _AIX  not MSDOS, or __TURBOC__ or _AIX, not sparc.  */
#endif /* alloca not defined.  */

#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif

#ifdef __cplusplus
#ifndef YY_USE_CLASS
/*#warning "For C++ its recomended to use bison++, otherwise classes won't be generated"*/
#endif
#else
#ifndef __STDC__
#define const
#endif
#ifdef YY_USE_CLASS
#error "This is a C++ header generated by bison++, please use a C++ compiler!"
#endif
#endif

#include <stdio.h>
#define YYBISON 1

#line 88 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"
#line 5 "dxreader.yacc"

// #define YYSTYPE double

#include <util/coviseCompat.h>

#if defined(__hpux) || defined(__sgi)
#include <alloca.h>
#endif

/* #include <covise/FlexLexer.h> */
#include "attribute.h"
#include "scanner.h"

#include <api/coModule.h>
#include "parser.h"
/* The action class is the interface between parser and the rest of the compiler
   depending on its implementation
*/

#include "action.h"

#line 31 "dxreader.yacc"
typedef union
{
    attribute *attr;
} yy_Parser_stype;
#define YY_Parser_STYPE yy_Parser_stype
#define YY_Parser_MEMBERS                               \
    ifstream input;                                     \
    Scanner *lexer;                                     \
    char *currFileName_;                                \
    char *currDirName_;                                 \
    bool isOpen_;                                       \
    bool isCorrect_;                                    \
    actionClass *action;                                \
    virtual ~Parser()                                   \
    {                                                   \
        input.close();                                  \
        delete currFileName_;                           \
        delete currDirName_;                            \
    }                                                   \
    Parser(actionClass *act, const char *fileName)      \
    {                                                   \
        currFileName_ = new char[1 + strlen(fileName)]; \
        strcpy(currFileName_, fileName);                \
        currDirName_ = new char[1 + strlen(fileName)];  \
        strcpy(currDirName_, fileName);                 \
        myDirName(currDirName_);                        \
        action = act;                                   \
        input.open(fileName, ios::in);                  \
        isOpen_ = !(!input);                            \
        isCorrect_ = true;                              \
        lexer = new Scanner(&input);                    \
    }                                                   \
    bool isOpen() { return isOpen_; }                   \
    bool isCorrect() { return isCorrect_; }             \
    void myDirName(char *filename)                      \
    {                                                   \
        int len = strlen(filename);                     \
        int i;                                          \
        for (i = len - 1; i >= 0; i--)                  \
        {                                               \
            if (filename[i] == '/')                     \
            {                                           \
                filename[i] = '\0';                     \
                return;                                 \
            }                                           \
        }                                               \
    }                                                   \
    void setCurrFileName(const char *name)              \
    {                                                   \
        delete[] currFileName_;                         \
        currFileName_ = new char[1 + strlen(name)];     \
        strcpy(currFileName_, name);                    \
    }                                                   \
    char *getCurrFileName() { return currFileName_; }   \
    void setCurrDirName(const char *name)               \
    {                                                   \
        delete[] currDirName_;                          \
        currDirName_ = new char[1 + strlen(name)];      \
        strcpy(currDirName_, name);                     \
    }                                                   \
    char *getCurrDirName() { return currDirName_; }

#define YY_Parser_LEX_BODY     \
    {                          \
        return lexer->yylex(); \
    }
#define YY_Parser_ERROR_BODY                                                                               \
    {                                                                                                      \
        char comsg[4096];                                                                                  \
        sprintf(comsg, "Syntax error in line %d; %s not recognized", lexer->getLineNo(), lexer->YYText()); \
        Covise::sendError(comsg);                                                                          \
        isCorrect_ = false;                                                                                \
    }

#line 88 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"
/* %{ and %header{ and %union, during decl */
#define YY_Parser_BISON 1

#ifndef YY_Parser_COMPATIBILITY
#ifndef YY_USE_CLASS
#define YY_Parser_COMPATIBILITY 1
#else
#define YY_Parser_COMPATIBILITY 0
#endif
#endif

#if YY_Parser_COMPATIBILITY != 0
/* backward compatibility */
#ifdef YYLTYPE
#ifndef YY_Parser_LTYPE
#define YY_Parser_LTYPE YYLTYPE
#endif
#endif
/* Testing alternative bison solution
   /#ifdef YYSTYPE*/
#ifndef YY_Parser_STYPE
#define YY_Parser_STYPE YYSTYPE
#endif
/*#endif*/
#ifdef YYDEBUG
#ifndef YY_Parser_DEBUG
#define YY_Parser_DEBUG YYDEBUG
#endif
#endif

/* use goto to be compatible */
#ifndef YY_Parser_USE_GOTO
#define YY_Parser_USE_GOTO 1
#endif
#endif

/* use no goto to be clean in C++ */
#ifndef YY_Parser_USE_GOTO
#define YY_Parser_USE_GOTO 0
#endif

#ifndef YY_Parser_PURE

#line 130 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"

#line 130 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"
/*  YY_Parser_PURE */
#endif

/* section apres lecture def, avant lecture grammaire S2 */

#line 134 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"

#line 134 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"
/* prefix */
#ifndef YY_Parser_DEBUG

#line 136 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"

#line 136 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"
/* YY_Parser_DEBUG */
#endif

#ifndef YY_Parser_LSP_NEEDED

#line 141 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"

#line 141 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"
/* YY_Parser_LSP_NEEDED*/
#endif

/* DEFAULT LTYPE*/
#ifdef YY_Parser_LSP_NEEDED
#ifndef YY_Parser_LTYPE
#ifndef BISON_YYLTYPE_ISDECLARED
#define BISON_YYLTYPE_ISDECLARED
typedef struct yyltype
{
    int timestamp;
    int first_line;
    int first_column;
    int last_line;
    int last_column;
    char *text;
} yyltype;

#endif
#define YY_Parser_LTYPE yyltype
#endif
#endif
/* DEFAULT STYPE*/
/* We used to use `unsigned long' as YY_Parser_STYPE on MSDOS,
	 but it seems better to be consistent.
	 Most programs should declare their own type anyway.  */

#ifndef YY_Parser_STYPE
#define YY_Parser_STYPE int
#endif
/* DEFAULT MISCELANEOUS */
#ifndef YY_Parser_PARSE
#define YY_Parser_PARSE yyparse
#endif
#ifndef YY_Parser_LEX
#define YY_Parser_LEX yylex
#endif
#ifndef YY_Parser_LVAL
#define YY_Parser_LVAL yylval
#endif
#ifndef YY_Parser_LLOC
#define YY_Parser_LLOC yylloc
#endif
#ifndef YY_Parser_CHAR
#define YY_Parser_CHAR yychar
#endif
#ifndef YY_Parser_NERRS
#define YY_Parser_NERRS yynerrs
#endif
#ifndef YY_Parser_DEBUG_FLAG
#define YY_Parser_DEBUG_FLAG yydebug
#endif
#ifndef YY_Parser_ERROR
#define YY_Parser_ERROR yyerror
#endif

#ifndef YY_Parser_PARSE_PARAM
#ifndef YY_USE_CLASS
#ifdef YYPARSE_PARAM
#define YY_Parser_PARSE_PARAM void *YYPARSE_PARAM
#else
#ifndef __STDC__
#ifndef __cplusplus
#define YY_Parser_PARSE_PARAM
#endif
#endif
#endif
#endif
#ifndef YY_Parser_PARSE_PARAM
#define YY_Parser_PARSE_PARAM void
#endif
#endif

#if YY_Parser_COMPATIBILITY != 0
/* backward compatibility */
#ifdef YY_Parser_LTYPE
#ifndef YYLTYPE
#define YYLTYPE YY_Parser_LTYPE
#else
/* WARNING obsolete !!! user defined YYLTYPE not reported into generated header */
#endif
#endif

/* Removed due to bison compabilityproblems
/#ifndef YYSTYPE
/#define YYSTYPE YY_Parser_STYPE
/#else*/
/* WARNING obsolete !!! user defined YYSTYPE not reported into generated header */
/*#endif*/

#ifdef YY_Parser_PURE
#ifndef YYPURE
#define YYPURE YY_Parser_PURE
#endif
#endif

#ifdef YY_Parser_DEBUG
#ifndef YYDEBUG
#define YYDEBUG YY_Parser_DEBUG
#endif
#endif

#ifndef YY_Parser_ERROR_VERBOSE
#ifdef YYERROR_VERBOSE
#define YY_Parser_ERROR_VERBOSE YYERROR_VERBOSE
#endif
#endif

#ifndef YY_Parser_LSP_NEEDED
#ifdef YYLSP_NEEDED
#define YY_Parser_LSP_NEEDED YYLSP_NEEDED
#endif
#endif

#endif

#ifndef YY_USE_CLASS
/* TOKEN C */

#line 263 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"
#define INTEGERVALUE 258
#define FLOATVALUE 259
#define STRINGVALUE 260
#define OBJECT 261
#define CLASS 262
#define ARRAY 263
#define FIELD 264
#define MULTIGRID 265
#define GROUP 266
#define FILENAME 267
#define MEMBER 268
#define TYPE 269
#define BINARY 270
#define ASCII 271
#define COMMA 272
#define SHAPE 273
#define DOUBLE 274
#define FLOAT 275
#define INT 276
#define UINT 277
#define SHORT 278
#define USHORT 279
#define BYTE 280
#define UBYTE 281
#define RANK 282
#define ITEMS 283
#define DATA 284
#define FOLLOWS 285
#define FILE 286
#define ATTRIBUTEREF 287
#define ATTRIBUTEELTYPE 288
#define ATTRIBUTENAME 289
#define ATTRIBUTEDEP 290
#define CPOSITIONS 291
#define CCONNECTIONS 292
#define CDATA 293
#define VALUE 294
#define STRING 295
#define LSB 296
#define MSB 297
#define END 298

#line 263 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"
/* #defines tokens */
#else
/* CLASS */
#ifndef YY_Parser_CLASS
#define YY_Parser_CLASS Parser
#endif
#ifndef YY_Parser_INHERIT
#define YY_Parser_INHERIT
#endif
#ifndef YY_Parser_MEMBERS
#define YY_Parser_MEMBERS
#endif
#ifndef YY_Parser_LEX_BODY
#define YY_Parser_LEX_BODY
#endif
#ifndef YY_Parser_ERROR_BODY
#define YY_Parser_ERROR_BODY
#endif
#ifndef YY_Parser_CONSTRUCTOR_PARAM
#define YY_Parser_CONSTRUCTOR_PARAM
#endif
#ifndef YY_Parser_CONSTRUCTOR_CODE
#define YY_Parser_CONSTRUCTOR_CODE
#endif
#ifndef YY_Parser_CONSTRUCTOR_INIT
#define YY_Parser_CONSTRUCTOR_INIT
#endif
/* choose between enum and const */
#ifndef YY_Parser_USE_CONST_TOKEN
#define YY_Parser_USE_CONST_TOKEN 0
/* yes enum is more compatible with flex,  */
/* so by default we use it */
#endif
#if YY_Parser_USE_CONST_TOKEN != 0
#ifndef YY_Parser_ENUM_TOKEN
#define YY_Parser_ENUM_TOKEN yy_Parser_enum_token
#endif
#endif

class YY_Parser_CLASS YY_Parser_INHERIT
{
public:
#if YY_Parser_USE_CONST_TOKEN != 0
/* static const int token ... */

#line 307 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"
    static const int INTEGERVALUE;
    static const int FLOATVALUE;
    static const int STRINGVALUE;
    static const int OBJECT;
    static const int CLASS;
    static const int ARRAY;
    static const int FIELD;
    static const int MULTIGRID;
    static const int GROUP;
    static const int FILENAME;
    static const int MEMBER;
    static const int TYPE;
    static const int BINARY;
    static const int ASCII;
    static const int COMMA;
    static const int SHAPE;
    static const int DOUBLE;
    static const int FLOAT;
    static const int INT;
    static const int UINT;
    static const int SHORT;
    static const int USHORT;
    static const int BYTE;
    static const int UBYTE;
    static const int RANK;
    static const int ITEMS;
    static const int DATA;
    static const int FOLLOWS;
    static const int FILE;
    static const int ATTRIBUTEREF;
    static const int ATTRIBUTEELTYPE;
    static const int ATTRIBUTENAME;
    static const int ATTRIBUTEDEP;
    static const int CPOSITIONS;
    static const int CCONNECTIONS;
    static const int CDATA;
    static const int VALUE;
    static const int STRING;
    static const int LSB;
    static const int MSB;
    static const int END;

#line 307 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"
/* decl const */
#else
    enum YY_Parser_ENUM_TOKEN
    {
        YY_Parser_NULL_TOKEN = 0

#line 310 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"
        ,
        INTEGERVALUE = 258,
        FLOATVALUE = 259,
        STRINGVALUE = 260,
        OBJECT = 261,
        CLASS = 262,
        ARRAY = 263,
        FIELD = 264,
        MULTIGRID = 265,
        GROUP = 266,
        FILENAME = 267,
        MEMBER = 268,
        TYPE = 269,
        BINARY = 270,
        ASCII = 271,
        COMMA = 272,
        SHAPE = 273,
        DOUBLE = 274,
        FLOAT = 275,
        INT = 276,
        UINT = 277,
        SHORT = 278,
        USHORT = 279,
        BYTE = 280,
        UBYTE = 281,
        RANK = 282,
        ITEMS = 283,
        DATA = 284,
        FOLLOWS = 285,
        FILE = 286,
        ATTRIBUTEREF = 287,
        ATTRIBUTEELTYPE = 288,
        ATTRIBUTENAME = 289,
        ATTRIBUTEDEP = 290,
        CPOSITIONS = 291,
        CCONNECTIONS = 292,
        CDATA = 293,
        VALUE = 294,
        STRING = 295,
        LSB = 296,
        MSB = 297,
        END = 298

#line 310 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"
        /* enum token */
    }; /* end of enum declaration */
#endif
public:
    int YY_Parser_PARSE(YY_Parser_PARSE_PARAM);
    virtual void YY_Parser_ERROR(char *msg) YY_Parser_ERROR_BODY;
#ifdef YY_Parser_PURE
#ifdef YY_Parser_LSP_NEEDED
    virtual int YY_Parser_LEX(YY_Parser_STYPE *YY_Parser_LVAL, YY_Parser_LTYPE *YY_Parser_LLOC) YY_Parser_LEX_BODY;
#else
    virtual int YY_Parser_LEX(YY_Parser_STYPE *YY_Parser_LVAL) YY_Parser_LEX_BODY;
#endif
#else
    virtual int YY_Parser_LEX() YY_Parser_LEX_BODY;
    YY_Parser_STYPE YY_Parser_LVAL;
#ifdef YY_Parser_LSP_NEEDED
    YY_Parser_LTYPE YY_Parser_LLOC;
#endif
    int YY_Parser_NERRS;
    int YY_Parser_CHAR;
#endif
#if YY_Parser_DEBUG != 0
    int YY_Parser_DEBUG_FLAG; /*  nonzero means print parse trace     */
#endif
public:
    YY_Parser_CLASS(YY_Parser_CONSTRUCTOR_PARAM);

public:
    YY_Parser_MEMBERS
};
/* other declare folow */
#if YY_Parser_USE_CONST_TOKEN != 0

#line 341 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"
const int YY_Parser_CLASS::INTEGERVALUE = 258;
const int YY_Parser_CLASS::FLOATVALUE = 259;
const int YY_Parser_CLASS::STRINGVALUE = 260;
const int YY_Parser_CLASS::OBJECT = 261;
const int YY_Parser_CLASS::CLASS = 262;
const int YY_Parser_CLASS::ARRAY = 263;
const int YY_Parser_CLASS::FIELD = 264;
const int YY_Parser_CLASS::MULTIGRID = 265;
const int YY_Parser_CLASS::GROUP = 266;
const int YY_Parser_CLASS::FILENAME = 267;
const int YY_Parser_CLASS::MEMBER = 268;
const int YY_Parser_CLASS::TYPE = 269;
const int YY_Parser_CLASS::BINARY = 270;
const int YY_Parser_CLASS::ASCII = 271;
const int YY_Parser_CLASS::COMMA = 272;
const int YY_Parser_CLASS::SHAPE = 273;
const int YY_Parser_CLASS::DOUBLE = 274;
const int YY_Parser_CLASS::FLOAT = 275;
const int YY_Parser_CLASS::INT = 276;
const int YY_Parser_CLASS::UINT = 277;
const int YY_Parser_CLASS::SHORT = 278;
const int YY_Parser_CLASS::USHORT = 279;
const int YY_Parser_CLASS::BYTE = 280;
const int YY_Parser_CLASS::UBYTE = 281;
const int YY_Parser_CLASS::RANK = 282;
const int YY_Parser_CLASS::ITEMS = 283;
const int YY_Parser_CLASS::DATA = 284;
const int YY_Parser_CLASS::FOLLOWS = 285;
const int YY_Parser_CLASS::FILE = 286;
const int YY_Parser_CLASS::ATTRIBUTEREF = 287;
const int YY_Parser_CLASS::ATTRIBUTEELTYPE = 288;
const int YY_Parser_CLASS::ATTRIBUTENAME = 289;
const int YY_Parser_CLASS::ATTRIBUTEDEP = 290;
const int YY_Parser_CLASS::CPOSITIONS = 291;
const int YY_Parser_CLASS::CCONNECTIONS = 292;
const int YY_Parser_CLASS::CDATA = 293;
const int YY_Parser_CLASS::VALUE = 294;
const int YY_Parser_CLASS::STRING = 295;
const int YY_Parser_CLASS::LSB = 296;
const int YY_Parser_CLASS::MSB = 297;
const int YY_Parser_CLASS::END = 298;

#line 341 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"
/* const YY_Parser_CLASS::token */
#endif
/*apres const  */
YY_Parser_CLASS::YY_Parser_CLASS(YY_Parser_CONSTRUCTOR_PARAM) YY_Parser_CONSTRUCTOR_INIT
{
#if YY_Parser_DEBUG != 0
    YY_Parser_DEBUG_FLAG = 0;
#endif
    YY_Parser_CONSTRUCTOR_CODE;
};
#endif

#line 352 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"

#define YYFINAL 124
#define YYFLAG -32768
#define YYNTBASE 44

#define YYTRANSLATE(x) ((unsigned)(x) <= 298 ? yytranslate[x] : 63)

static const char yytranslate[] = { 0,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                    2, 2, 2, 2, 2, 1, 2, 3, 4, 5,
                                    6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                                    16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
                                    26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
                                    36, 37, 38, 39, 40, 41, 42, 43 };

#if YY_Parser_DEBUG != 0
static const short yyprhs[] = { 0,
                                0, 3, 5, 6, 9, 12, 14, 16, 18, 20,
                                26, 32, 33, 36, 39, 45, 51, 52, 59, 65,
                                71, 77, 83, 84, 91, 97, 103, 107, 111, 115,
                                119, 123, 127, 128, 130, 131, 136, 141, 146, 151,
                                159, 167, 168, 172, 176, 180, 184, 186, 188, 190,
                                192, 194, 196, 198, 200, 203, 210, 214, 220, 223,
                                224, 226, 229, 232, 234, 236, 238 };

static const short yyrhs[] = { 45,
                               43, 0, 45, 0, 0, 45, 46, 0, 45, 1,
                               0, 47, 0, 56, 0, 49, 0, 51, 0, 6,
                               61, 7, 9, 48, 0, 6, 62, 7, 9, 48,
                               0, 0, 48, 53, 0, 48, 55, 0, 6, 62,
                               7, 10, 50, 0, 6, 61, 7, 10, 50, 0,
                               0, 50, 13, 40, 62, 54, 62, 0, 50, 13,
                               62, 54, 62, 0, 50, 13, 61, 54, 62, 0,
                               6, 62, 7, 11, 52, 0, 6, 61, 7, 11,
                               52, 0, 0, 52, 13, 40, 62, 54, 62, 0,
                               52, 13, 62, 54, 62, 0, 52, 13, 61, 54,
                               62, 0, 36, 54, 61, 0, 38, 54, 61, 0,
                               37, 54, 61, 0, 36, 54, 62, 0, 38, 54,
                               62, 0, 37, 54, 62, 0, 0, 39, 0, 0,
                               55, 32, 40, 62, 0, 55, 33, 40, 62, 0,
                               55, 35, 40, 62, 0, 55, 34, 40, 62, 0,
                               6, 61, 7, 8, 57, 59, 55, 0, 6, 62,
                               7, 8, 57, 59, 55, 0, 0, 57, 27, 61,
                               0, 57, 28, 61, 0, 57, 14, 58, 0, 57,
                               18, 61, 0, 19, 0, 20, 0, 21, 0, 22,
                               0, 23, 0, 24, 0, 25, 0, 26, 0, 29,
                               30, 0, 60, 29, 31, 62, 17, 61, 0, 60,
                               29, 61, 0, 29, 31, 62, 17, 61, 0, 29,
                               61, 0, 0, 15, 0, 42, 15, 0, 41, 15,
                               0, 16, 0, 3, 0, 4, 0, 5, 0 };

#endif

#if (YY_Parser_DEBUG != 0) || defined(YY_Parser_ERROR_VERBOSE)
static const short yyrline[] = { 0,
                                 150, 151, 154, 155, 156, 159, 160, 161, 162, 165,
                                 171, 179, 180, 181, 184, 185, 187, 188, 189, 190,
                                 194, 195, 197, 198, 199, 200, 203, 204, 205, 206,
                                 207, 208, 210, 211, 215, 216, 217, 218, 219, 222,
                                 232, 243, 244, 245, 246, 247, 250, 251, 252, 253,
                                 254, 255, 256, 257, 260, 261, 266, 271, 276, 285,
                                 286, 287, 288, 289, 293, 294, 297 };

static const char *const yytname[] = { "$", "error", "$illegal.", "INTEGERVALUE",
                                       "FLOATVALUE", "STRINGVALUE", "OBJECT", "CLASS", "ARRAY", "FIELD", "MULTIGRID", "GROUP",
                                       "FILENAME", "MEMBER", "TYPE", "BINARY", "ASCII", "COMMA", "SHAPE", "DOUBLE", "FLOAT",
                                       "INT", "UINT", "SHORT", "USHORT", "BYTE", "UBYTE", "RANK", "ITEMS", "DATA", "FOLLOWS",
                                       "FILE", "ATTRIBUTEREF", "ATTRIBUTEELTYPE", "ATTRIBUTENAME", "ATTRIBUTEDEP", "CPOSITIONS",
                                       "CCONNECTIONS", "CDATA", "VALUE", "STRING", "LSB", "MSB", "END", "input", "objects",
                                       "object", "field", "fieldspec", "multigrid", "multigridspec", "group", "groupspec",
                                       "component", "value", "attributes", "array", "arraymodifiers", "type", "datasource",
                                       "dataformat", "number", "stringvalue", "" };
#endif

static const short yyr1[] = { 0,
                              44, 44, 45, 45, 45, 46, 46, 46, 46, 47,
                              47, 48, 48, 48, 49, 49, 50, 50, 50, 50,
                              51, 51, 52, 52, 52, 52, 53, 53, 53, 53,
                              53, 53, 54, 54, 55, 55, 55, 55, 55, 56,
                              56, 57, 57, 57, 57, 57, 58, 58, 58, 58,
                              58, 58, 58, 58, 59, 59, 59, 59, 59, 60,
                              60, 60, 60, 60, 61, 61, 62 };

static const short yyr2[] = { 0,
                              2, 1, 0, 2, 2, 1, 1, 1, 1, 5,
                              5, 0, 2, 2, 5, 5, 0, 6, 5, 5,
                              5, 5, 0, 6, 5, 5, 3, 3, 3, 3,
                              3, 3, 0, 1, 0, 4, 4, 4, 4, 7,
                              7, 0, 3, 3, 3, 3, 1, 1, 1, 1,
                              1, 1, 1, 1, 2, 6, 3, 5, 2, 0,
                              1, 2, 2, 1, 1, 1, 1 };

static const short yydefact[] = { 3,
                                  0, 5, 0, 1, 4, 6, 8, 9, 7, 65,
                                  66, 67, 0, 0, 0, 0, 42, 12, 17, 23,
                                  42, 12, 17, 23, 0, 10, 16, 22, 0, 11,
                                  15, 21, 0, 61, 64, 0, 0, 0, 0, 0,
                                  0, 35, 0, 33, 33, 33, 13, 14, 0, 0,
                                  35, 47, 48, 49, 50, 51, 52, 53, 54, 45,
                                  46, 43, 44, 55, 0, 59, 63, 62, 40, 0,
                                  34, 0, 0, 0, 0, 0, 0, 0, 0, 33,
                                  33, 0, 33, 33, 41, 0, 0, 57, 27, 30,
                                  29, 32, 28, 31, 0, 0, 0, 0, 33, 0,
                                  0, 33, 0, 0, 0, 0, 36, 37, 39, 38,
                                  0, 20, 19, 0, 26, 25, 58, 0, 18, 24,
                                  56, 0, 0, 0 };

static const short yydefgoto[] = { 122,
                                   1, 5, 6, 26, 7, 27, 8, 28, 47, 72,
                                   48, 9, 25, 60, 42, 43, 13, 14 };

static const short yypact[] = { -32768,
                                4, -32768, 121, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
                                -32768, -32768, 2, 12, 104, 108, -32768, -32768, -32768, -32768,
                                -32768, -32768, -32768, -32768, 69, 56, 9, 13, 69, 56,
                                9, 13, 80, -32768, -32768, 8, 8, 8, 49, 0,
                                16, -32768, -1, -6, -6, -6, -32768, 88, 3, 20,
                                -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
                                -32768, -32768, -32768, -32768, 30, -32768, -32768, -32768, 88, 26,
                                -32768, 121, 121, 121, 5, 10, 11, 21, 30, -6,
                                -6, 30, -6, -6, 88, 25, 30, -32768, -32768, -32768,
                                -32768, -32768, -32768, -32768, 30, 30, 30, 30, -6, 30,
                                30, -6, 30, 30, 8, 27, -32768, -32768, -32768, -32768,
                                30, -32768, -32768, 30, -32768, -32768, -32768, 8, -32768, -32768,
                                -32768, 48, 66, -32768 };

static const short yypgoto[] = { -32768,
                                 -32768, -32768, -32768, 50, -32768, 52, -32768, 62, -32768, -25,
                                 -24, -32768, 55, -32768, 44, -32768, -36, -33 };

#define YYLAST 126

static const short yytable[] = { 61,
                                 62, 63, 66, -2, 2, 10, 11, 12, 15, 3,
                                 10, 11, 80, 83, 67, 81, 84, 69, 16, 73,
                                 74, 49, 10, 11, 12, 50, 85, 70, 10, 11,
                                 68, 86, 71, 88, 12, 89, 91, 93, 90, 92,
                                 94, 105, 79, 118, 95, 99, 4, 123, 102, 96,
                                 97, 10, 11, 106, 100, 101, 87, 103, 104, 82,
                                 98, 107, 108, 109, 110, 124, 112, 113, 117, 115,
                                 116, 30, 51, 111, 31, 29, 114, 119, 64, 65,
                                 120, 121, 33, 34, 35, 32, 36, -35, -35, -35,
                                 -35, 44, 45, 46, 0, 37, 38, 39, 52, 53,
                                 54, 55, 56, 57, 58, 59, 0, 0, 0, 40,
                                 41, 17, 18, 19, 20, 21, 22, 23, 24, 75,
                                 76, 77, 78, 10, 11, 12 };

static const short yycheck[] = { 36,
                                 37, 38, 39, 0, 1, 3, 4, 5, 7, 6,
                                 3, 4, 49, 50, 15, 49, 50, 42, 7, 45,
                                 46, 13, 3, 4, 5, 13, 51, 29, 3, 4,
                                 15, 65, 39, 70, 5, 72, 73, 74, 72, 73,
                                 74, 17, 40, 17, 40, 79, 43, 0, 82, 40,
                                 40, 3, 4, 87, 80, 81, 31, 83, 84, 40,
                                 40, 95, 96, 97, 98, 0, 100, 101, 105, 103,
                                 104, 22, 29, 99, 23, 21, 102, 111, 30, 31,
                                 114, 118, 14, 15, 16, 24, 18, 32, 33, 34,
                                 35, 36, 37, 38, -1, 27, 28, 29, 19, 20,
                                 21, 22, 23, 24, 25, 26, -1, -1, -1, 41,
                                 42, 8, 9, 10, 11, 8, 9, 10, 11, 32,
                                 33, 34, 35, 3, 4, 5 };

#line 352 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"
/* fattrs + tables */

/* parser code folow  */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: dollar marks section change
   the next  is replaced by the list of actions, each action
   as one case of the switch.  */

#if YY_Parser_USE_GOTO != 0
/* 
 SUPRESSION OF GOTO : on some C++ compiler (sun c++)
  the goto is strictly forbidden if any constructor/destructor
  is used in the whole function (very stupid isn't it ?)
 so goto are to be replaced with a 'while/switch/case construct'
 here are the macro to keep some apparent compatibility
*/
#define YYGOTO(lb)         \
    {                      \
        yy_gotostate = lb; \
        continue;          \
    }
#define YYBEGINGOTO                            \
    enum yy_labels yy_gotostate = yygotostart; \
    for (;;)                                   \
        switch (yy_gotostate)                  \
        {                                      \
        case yygotostart:                      \
        {
#define YYLABEL(lb) \
    }               \
    case lb:        \
    {
#define YYENDGOTO \
    }             \
    }
#define YYBEGINDECLARELABEL enum yy_labels \
{                                          \
  yygotostart
#define YYDECLARELABEL(lb) , lb
#define YYENDDECLARELABEL \
    }                     \
    ;
#else
/* macro to keep goto */
#define YYGOTO(lb) goto lb
#define YYBEGINGOTO
#define YYLABEL(lb) lb:
#define YYENDGOTO
#define YYBEGINDECLARELABEL
#define YYDECLARELABEL(lb)
#define YYENDDECLARELABEL
#endif
/* LABEL DECLARATION */
YYBEGINDECLARELABEL
YYDECLARELABEL(yynewstate)
YYDECLARELABEL(yybackup)
/* YYDECLARELABEL(yyresume) */
YYDECLARELABEL(yydefault)
YYDECLARELABEL(yyreduce)
YYDECLARELABEL(yyerrlab) /* here on detecting error */
YYDECLARELABEL(yyerrlab1) /* here on error raised explicitly by an action */
YYDECLARELABEL(yyerrdefault) /* current state does not do anything special for the error token. */
YYDECLARELABEL(yyerrpop) /* pop the current state because it cannot handle the error token */
YYDECLARELABEL(yyerrhandle)
YYENDDECLARELABEL
/* ALLOCA SIMULATION */
/* __HAVE_NO_ALLOCA */
#ifdef __HAVE_NO_ALLOCA
int __alloca_free_ptr(char *ptr, char *ref)
{
    if (ptr != ref)
        free(ptr);
    return 0;
}

#define __ALLOCA_alloca(size) malloc(size)
#define __ALLOCA_free(ptr, ref) __alloca_free_ptr((char *)ptr, (char *)ref)

#ifdef YY_Parser_LSP_NEEDED
#define __ALLOCA_return(num)                                                                                   \
    do                                                                                                         \
    {                                                                                                          \
        return (__ALLOCA_free(yyss, yyssa) + __ALLOCA_free(yyvs, yyvsa) + __ALLOCA_free(yyls, yylsa) + (num)); \
    } while (0)
#else
#define __ALLOCA_return(num)                                                      \
    do                                                                            \
    {                                                                             \
        return (__ALLOCA_free(yyss, yyssa) + __ALLOCA_free(yyvs, yyvsa) + (num)); \
    } while (0)
#endif
#else
#define __ALLOCA_return(num) \
    do                       \
    {                        \
        return (num);        \
    } while (0)
#define __ALLOCA_alloca(size) alloca(size)
#define __ALLOCA_free(ptr, ref)
#endif

/* ENDALLOCA SIMULATION */

#define yyerrok (yyerrstatus = 0)
#define yyclearin (YY_Parser_CHAR = YYEMPTY)
#define YYEMPTY -2
#define YYEOF 0
#define YYACCEPT __ALLOCA_return(0)
#define YYABORT __ALLOCA_return(1)
#define YYERROR YYGOTO(yyerrlab1)
/* Like YYERROR except do call yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL YYGOTO(yyerrlab)
#define YYRECOVERING() (!!yyerrstatus)
#define YYBACKUP(token, value)                                  \
    do                                                          \
        if (YY_Parser_CHAR == YYEMPTY && yylen == 1)            \
        {                                                       \
            YY_Parser_CHAR = (token), YY_Parser_LVAL = (value); \
            yychar1 = YYTRANSLATE(YY_Parser_CHAR);              \
            YYPOPSTACK;                                         \
            YYGOTO(yybackup);                                   \
        }                                                       \
        else                                                    \
        {                                                       \
            YY_Parser_ERROR("syntax error: cannot back up");    \
            YYERROR;                                            \
        }                                                       \
    while (0)

#define YYTERROR 1
#define YYERRCODE 256

#ifndef YY_Parser_PURE
/* UNPURE */
#define YYLEX YY_Parser_LEX()
#ifndef YY_USE_CLASS
/* If nonreentrant, and not class , generate the variables here */
int YY_Parser_CHAR; /*  the lookahead symbol        */
YY_Parser_STYPE YY_Parser_LVAL; /*  the semantic value of the */
/*  lookahead symbol    */
int YY_Parser_NERRS; /*  number of parse errors so far */
#ifdef YY_Parser_LSP_NEEDED
YY_Parser_LTYPE YY_Parser_LLOC; /*  location data for the lookahead     */
/*  symbol                              */
#endif
#endif

#else
/* PURE */
#ifdef YY_Parser_LSP_NEEDED
#define YYLEX YY_Parser_LEX(&YY_Parser_LVAL, &YY_Parser_LLOC)
#else
#define YYLEX YY_Parser_LEX(&YY_Parser_LVAL)
#endif
#endif
#ifndef YY_USE_CLASS
#if YY_Parser_DEBUG != 0
int YY_Parser_DEBUG_FLAG; /*  nonzero means print parse trace     */
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif
#endif

/*  YYINITDEPTH indicates the initial size of the parser's stacks       */

#ifndef YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

#if __GNUC__ > 1 /* GNU C and GNU C++ define this.  */
#define __yy_bcopy(FROM, TO, COUNT) __builtin_memcpy(TO, FROM, COUNT)
#else /* not GNU C or C++ */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */

#ifdef __cplusplus
static void __yy_bcopy(char *from, char *to, int count)
#else
#ifdef __STDC__
static void __yy_bcopy(char *from, char *to, int count)
#else
static void __yy_bcopy(from, to, count) char *from;
char *to;
int count;
#endif
#endif
{
    register char *f = from;
    register char *t = to;
    register int i = count;

    while (i-- > 0)
        *t++ = *f++;
}
#endif

int
#ifdef YY_USE_CLASS
    YY_Parser_CLASS::
#endif
        YY_Parser_PARSE(YY_Parser_PARSE_PARAM)
#ifndef __STDC__
#ifndef __cplusplus
#ifndef YY_USE_CLASS
            /* parameter definition without protypes */
    YY_Parser_PARSE_PARAM_DEF
#endif
#endif
#endif
{
    register int yystate;
    register int yyn;
    register short *yyssp;
    register YY_Parser_STYPE *yyvsp;
    int yyerrstatus; /*  number of tokens to shift before error messages enabled */
    int yychar1 = 0; /*  lookahead token as an internal (translated) token number */

    short yyssa[YYINITDEPTH]; /*  the state stack                     */
    YY_Parser_STYPE yyvsa[YYINITDEPTH]; /*  the semantic value stack            */

    short *yyss = yyssa; /*  refer to the stacks thru separate pointers */
    YY_Parser_STYPE *yyvs = yyvsa; /*  to allow yyoverflow to reallocate them elsewhere */

#ifdef YY_Parser_LSP_NEEDED
    YY_Parser_LTYPE yylsa[YYINITDEPTH]; /*  the location stack                  */
    YY_Parser_LTYPE *yyls = yylsa;
    YY_Parser_LTYPE *yylsp;

#define YYPOPSTACK (yyvsp--, yyssp--, yylsp--)
#else
#define YYPOPSTACK (yyvsp--, yyssp--)
#endif

    int yystacksize = YYINITDEPTH;

#ifdef YY_Parser_PURE
    int YY_Parser_CHAR;
    YY_Parser_STYPE YY_Parser_LVAL;
    int YY_Parser_NERRS;
#ifdef YY_Parser_LSP_NEEDED
    YY_Parser_LTYPE YY_Parser_LLOC;
#endif
#endif

    YY_Parser_STYPE yyval; /*  the variable used to return         */
    /*  semantic values from the action     */
    /*  routines                            */

    int yylen;
    /* start loop, in which YYGOTO may be used. */
    YYBEGINGOTO

#if YY_Parser_DEBUG != 0
    if (YY_Parser_DEBUG_FLAG)
        fprintf(stderr, "Starting parse\n");
#endif
    yystate = 0;
    yyerrstatus = 0;
    YY_Parser_NERRS = 0;
    YY_Parser_CHAR = YYEMPTY; /* Cause a token to be read.  */

    /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

    yyssp = yyss - 1;
    yyvsp = yyvs;
#ifdef YY_Parser_LSP_NEEDED
    yylsp = yyls;
#endif

    /* Push a new state, which is found in  yystate  .  */
    /* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
    YYLABEL(yynewstate)

    *++yyssp = yystate;

    if (yyssp >= yyss + yystacksize - 1)
    {
        /* Give user a chance to reallocate the stack */
        /* Use copies of these so that the &'s don't force the real ones into memory. */
        YY_Parser_STYPE *yyvs1 = yyvs;
        short *yyss1 = yyss;
#ifdef YY_Parser_LSP_NEEDED
        YY_Parser_LTYPE *yyls1 = yyls;
#endif

        /* Get the current used size of the three stacks, in elements.  */
        int size = yyssp - yyss + 1;

#ifdef yyoverflow
/* Each stack pointer address is followed by the size of
	 the data in use in that stack, in bytes.  */
#ifdef YY_Parser_LSP_NEEDED
        /* This used to be a conditional around just the two extra args,
	 but that might be undefined if yyoverflow is a macro.  */
        yyoverflow("parser stack overflow",
                   &yyss1, size * sizeof(*yyssp),
                   &yyvs1, size * sizeof(*yyvsp),
                   &yyls1, size * sizeof(*yylsp),
                   &yystacksize);
#else
        yyoverflow("parser stack overflow",
                   &yyss1, size * sizeof(*yyssp),
                   &yyvs1, size * sizeof(*yyvsp),
                   &yystacksize);
#endif

        yyss = yyss1;
        yyvs = yyvs1;
#ifdef YY_Parser_LSP_NEEDED
        yyls = yyls1;
#endif
#else /* no yyoverflow */
        /* Extend the stack our own way.  */
        if (yystacksize >= YYMAXDEPTH)
        {
            YY_Parser_ERROR("parser stack overflow");
            __ALLOCA_return(2);
        }
        yystacksize *= 2;
        if (yystacksize > YYMAXDEPTH)
            yystacksize = YYMAXDEPTH;
        yyss = (short *)__ALLOCA_alloca(yystacksize * sizeof(*yyssp));
        __yy_bcopy((char *)yyss1, (char *)yyss, size * sizeof(*yyssp));
        __ALLOCA_free(yyss1, yyssa);
        yyvs = (YY_Parser_STYPE *)__ALLOCA_alloca(yystacksize * sizeof(*yyvsp));
        __yy_bcopy((char *)yyvs1, (char *)yyvs, size * sizeof(*yyvsp));
        __ALLOCA_free(yyvs1, yyvsa);
#ifdef YY_Parser_LSP_NEEDED
        yyls = (YY_Parser_LTYPE *)__ALLOCA_alloca(yystacksize * sizeof(*yylsp));
        __yy_bcopy((char *)yyls1, (char *)yyls, size * sizeof(*yylsp));
        __ALLOCA_free(yyls1, yylsa);
#endif
#endif /* no yyoverflow */

        yyssp = yyss + size - 1;
        yyvsp = yyvs + size - 1;
#ifdef YY_Parser_LSP_NEEDED
        yylsp = yyls + size - 1;
#endif

#if YY_Parser_DEBUG != 0
        if (YY_Parser_DEBUG_FLAG)
            fprintf(stderr, "Stack size increased to %d\n", yystacksize);
#endif

        if (yyssp >= yyss + yystacksize - 1)
            YYABORT;
    }

#if YY_Parser_DEBUG != 0
    if (YY_Parser_DEBUG_FLAG)
        fprintf(stderr, "Entering state %d\n", yystate);
#endif

    YYGOTO(yybackup);
    YYLABEL(yybackup)

    /* Do appropriate processing given the current state.  */
    /* Read a lookahead token if we need one and don't already have one.  */
    /* YYLABEL(yyresume) */

    /* First try to decide what to do without reference to lookahead token.  */

    yyn = yypact[yystate];
    if (yyn == YYFLAG)
        YYGOTO(yydefault);

    /* Not known => get a lookahead token if don't already have one.  */

    /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

    if (YY_Parser_CHAR == YYEMPTY)
    {
#if YY_Parser_DEBUG != 0
        if (YY_Parser_DEBUG_FLAG)
            fprintf(stderr, "Reading a token: ");
#endif
        YY_Parser_CHAR = YYLEX;
    }

    /* Convert token to internal form (in yychar1) for indexing tables with */

    if (YY_Parser_CHAR <= 0) /* This means end of input. */
    {
        yychar1 = 0;
        YY_Parser_CHAR = YYEOF; /* Don't call YYLEX any more */

#if YY_Parser_DEBUG != 0
        if (YY_Parser_DEBUG_FLAG)
            fprintf(stderr, "Now at end of input.\n");
#endif
    }
    else
    {
        yychar1 = YYTRANSLATE(YY_Parser_CHAR);

#if YY_Parser_DEBUG != 0
        if (YY_Parser_DEBUG_FLAG)
        {
            fprintf(stderr, "Next token is %d (%s", YY_Parser_CHAR, yytname[yychar1]);
/* Give the individual parser a way to print the precise meaning
	     of a token, for further debugging info.  */
#ifdef YYPRINT
            YYPRINT(stderr, YY_Parser_CHAR, YY_Parser_LVAL);
#endif
            fprintf(stderr, ")\n");
        }
#endif
    }

    yyn += yychar1;
    if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
        YYGOTO(yydefault);

    yyn = yytable[yyn];

    /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

    if (yyn < 0)
    {
        if (yyn == YYFLAG)
            YYGOTO(yyerrlab);
        yyn = -yyn;
        YYGOTO(yyreduce);
    }
    else if (yyn == 0)
        YYGOTO(yyerrlab);

    if (yyn == YYFINAL)
        YYACCEPT;

/* Shift the lookahead token.  */

#if YY_Parser_DEBUG != 0
    if (YY_Parser_DEBUG_FLAG)
        fprintf(stderr, "Shifting token %d (%s), ", YY_Parser_CHAR, yytname[yychar1]);
#endif

    /* Discard the token being shifted unless it is eof.  */
    if (YY_Parser_CHAR != YYEOF)
        YY_Parser_CHAR = YYEMPTY;

    *++yyvsp = YY_Parser_LVAL;
#ifdef YY_Parser_LSP_NEEDED
    *++yylsp = YY_Parser_LLOC;
#endif

    /* count tokens shifted since error; after three, turn off error status.  */
    if (yyerrstatus)
        yyerrstatus--;

    yystate = yyn;
    YYGOTO(yynewstate);

    /* Do the default action for the current state.  */
    YYLABEL(yydefault)

    yyn = yydefact[yystate];
    if (yyn == 0)
        YYGOTO(yyerrlab);

    /* Do a reduction.  yyn is the number of a rule to reduce with.  */
    YYLABEL(yyreduce)
    yylen = yyr2[yyn];
    if (yylen > 0)
        yyval = yyvsp[1 - yylen]; /* implement default value of the action */

#if YY_Parser_DEBUG != 0
    if (YY_Parser_DEBUG_FLAG)
    {
        int i;

        fprintf(stderr, "Reducing via rule %d (line %d), ",
                yyn, yyrline[yyn]);

        /* Print the symbols being reduced, and their result.  */
        for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
            fprintf(stderr, "%s ", yytname[yyrhs[i]]);
        fprintf(stderr, " -> %s\n", yytname[yyr1[yyn]]);
    }
#endif

#line 839 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"

    switch (yyn)
    {

    case 1:
#line 150 "dxreader.yacc"
    {
        YYACCEPT;
        ;
        break;
    }
    case 2:
#line 151 "dxreader.yacc"
    {
        YYACCEPT;
        ;
        break;
    }
    case 10:
#line 165 "dxreader.yacc"
    {
        action->setCurrName(yyvsp[-3].attr->getInt());
        action->setCurrObjectClass(Parser::FIELD);
        action->fields_[action->getCurrName()] = action->getCurrObject();
        action->newCurrent();
        ;
        break;
    }
    case 11:
#line 171 "dxreader.yacc"
    {
        action->setCurrName(yyvsp[-3].attr->getString());
        action->setCurrObjectClass(Parser::FIELD);

        action->fields_[action->getCurrName()] = action->getCurrObject();
        action->newCurrent();
        ;
        break;
    }
    case 18:
#line 188 "dxreader.yacc"
    {
        action->addMember(yyvsp[-2].attr->getString(), yyvsp[0].attr->getString());
        ;
        break;
    }
    case 19:
#line 189 "dxreader.yacc"
    {
        action->addMember(yyvsp[-2].attr->getString(), yyvsp[0].attr->getString());
        ;
        break;
    }
    case 20:
#line 190 "dxreader.yacc"
    {
        action->addMember(yyvsp[-2].attr->getString(), yyvsp[0].attr->getString());
        ;
        break;
    }
    case 24:
#line 198 "dxreader.yacc"
    {
        action->addMember(yyvsp[-2].attr->getString(), yyvsp[0].attr->getString());
        ;
        break;
    }
    case 25:
#line 199 "dxreader.yacc"
    {
        action->addMember(yyvsp[-2].attr->getString(), yyvsp[0].attr->getString());
        ;
        break;
    }
    case 26:
#line 200 "dxreader.yacc"
    {
        action->addMember(yyvsp[-2].attr->getString(), yyvsp[0].attr->getString());
        ;
        break;
    }
    case 27:
#line 203 "dxreader.yacc"
    {
        action->setCurrPositions(yyvsp[0].attr->getInt());
        ;
        break;
    }
    case 28:
#line 204 "dxreader.yacc"
    {
        action->setCurrData(yyvsp[0].attr->getInt());
        ;
        break;
    }
    case 29:
#line 205 "dxreader.yacc"
    {
        action->setCurrConnections(yyvsp[0].attr->getInt());
        ;
        break;
    }
    case 30:
#line 206 "dxreader.yacc"
    {
        action->setCurrPositions(yyvsp[0].attr->getString());
        ;
        break;
    }
    case 31:
#line 207 "dxreader.yacc"
    {
        action->setCurrData(yyvsp[0].attr->getString());
        ;
        break;
    }
    case 32:
#line 208 "dxreader.yacc"
    {
        action->setCurrConnections(yyvsp[0].attr->getString());
        ;
        break;
    }
    case 36:
#line 216 "dxreader.yacc"
    {
        action->setCurrRef(yyvsp[0].attr->getString());
        ;
        break;
    }
    case 37:
#line 217 "dxreader.yacc"
    {
        action->setCurrElementType(yyvsp[0].attr->getString());
        ;
        break;
    }
    case 38:
#line 218 "dxreader.yacc"
    {
        action->setCurrAttributeDep(yyvsp[0].attr->getString());
        ;
        break;
    }
    case 39:
#line 219 "dxreader.yacc"
    {
        action->setCurrAttributeName(yyvsp[0].attr->getString());
        ;
        break;
    }
    case 40:
#line 222 "dxreader.yacc"
    {
        action->setCurrName(yyvsp[-5].attr->getInt());
        action->setCurrObjectClass(Parser::ARRAY);

        //store the recognized array object
        //in action->arrays
        action->arrays_[action->getCurrName()] = action->getCurrObject();
        //and create a new current object to be recognized
        action->newCurrent();
        ;
        break;
    }
    case 41:
#line 232 "dxreader.yacc"
    {
        action->setCurrName(yyvsp[-5].attr->getString());
        action->setCurrObjectClass(Parser::ARRAY);

        //store the recognized array object
        //in action->arrays
        action->arrays_[action->getCurrName()] = action->getCurrObject();
        //and create a new current object to be recognized
        action->newCurrent();
        ;
        break;
    }
    case 43:
#line 244 "dxreader.yacc"
    {
        action->setCurrRank(yyvsp[0].attr->getInt());
        ;
        break;
    }
    case 44:
#line 245 "dxreader.yacc"
    {
        action->setCurrItems(yyvsp[0].attr->getInt());
        ;
        break;
    }
    case 46:
#line 247 "dxreader.yacc"
    {
        action->setCurrShape(yyvsp[0].attr->getInt());
        ;
        break;
    }
    case 47:
#line 250 "dxreader.yacc"
    {
        action->setCurrType(Parser::DOUBLE);
        ;
        break;
    }
    case 48:
#line 251 "dxreader.yacc"
    {
        action->setCurrType(Parser::FLOAT);
        ;
        break;
    }
    case 49:
#line 252 "dxreader.yacc"
    {
        action->setCurrType(Parser::INT);
        ;
        break;
    }
    case 50:
#line 253 "dxreader.yacc"
    {
        action->setCurrType(Parser::UINT);
        ;
        break;
    }
    case 51:
#line 254 "dxreader.yacc"
    {
        action->setCurrType(Parser::SHORT);
        ;
        break;
    }
    case 52:
#line 255 "dxreader.yacc"
    {
        action->setCurrType(Parser::USHORT);
        ;
        break;
    }
    case 53:
#line 256 "dxreader.yacc"
    {
        action->setCurrType(Parser::BYTE);
        ;
        break;
    }
    case 54:
#line 257 "dxreader.yacc"
    {
        action->setCurrType(Parser::UBYTE);
        ;
        break;
    }
    case 55:
#line 260 "dxreader.yacc"
    {
        action->setCurrFollows(true);
        ;
        break;
    }
    case 56:
#line 261 "dxreader.yacc"
    {
        action->setCurrFollows(false);
        action->setCurrFileName(getCurrDirName(), yyvsp[-2].attr->getString());
        action->setCurrDataOffset(yyvsp[0].attr->getInt());
        ;
        break;
    }
    case 57:
#line 266 "dxreader.yacc"
    {
        action->setCurrFollows(false);
        action->setCurrFileName(NULL);
        action->setCurrDataOffset(yyvsp[0].attr->getInt());
        ;
        break;
    }
    case 58:
#line 271 "dxreader.yacc"
    {
        action->setCurrFollows(false);
        action->setCurrFileName(getCurrDirName(), yyvsp[-2].attr->getString());
        action->setCurrDataOffset(yyvsp[0].attr->getInt());
        ;
        break;
    }
    case 59:
#line 276 "dxreader.yacc"
    {
        action->setCurrFollows(false);
        action->setCurrFileName(NULL);
        action->setCurrDataOffset(yyvsp[0].attr->getInt());
        ;
        break;
    }
    case 61:
#line 286 "dxreader.yacc"
    {
        action->setCurrDataFormat(Parser::BINARY);
        break;
    }
    case 62:
#line 287 "dxreader.yacc"
    {
        action->setCurrByteOrder(Parser::MSB);
        action->setCurrDataFormat(Parser::BINARY);
        ;
        break;
    }
    case 63:
#line 288 "dxreader.yacc"
    {
        action->setCurrByteOrder(Parser::LSB);
        action->setCurrDataFormat(Parser::BINARY);
        ;
        break;
    }
    case 64:
#line 289 "dxreader.yacc"
    {
        action->setCurrDataFormat(Parser::ASCII);
        ;
        break;
    }
    case 65:
#line 293 "dxreader.yacc"
    {
        yyval.attr = new attribute(atoi(lexer->YYText()));
        ;
        break;
    }
    case 66:
#line 294 "dxreader.yacc"
    {
        yyval.attr = new attribute(atof(lexer->YYText()));
        ;
        break;
    }
    case 67:
#line 297 "dxreader.yacc"
    {
        attribute *temp = new attribute(lexer->YYText());
        yyval.attr = temp;
        ;
        break;
    }
    }

#line 839 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"
    /* the action file gets copied in in place of this dollarsign  */
    yyvsp -= yylen;
    yyssp -= yylen;
#ifdef YY_Parser_LSP_NEEDED
    yylsp -= yylen;
#endif

#if YY_Parser_DEBUG != 0
    if (YY_Parser_DEBUG_FLAG)
    {
        short *ssp1 = yyss - 1;
        fprintf(stderr, "state stack now");
        while (ssp1 != yyssp)
            fprintf(stderr, " %d", *++ssp1);
        fprintf(stderr, "\n");
    }
#endif

    *++yyvsp = yyval;

#ifdef YY_Parser_LSP_NEEDED
    yylsp++;
    if (yylen == 0)
    {
        yylsp->first_line = YY_Parser_LLOC.first_line;
        yylsp->first_column = YY_Parser_LLOC.first_column;
        yylsp->last_line = (yylsp - 1)->last_line;
        yylsp->last_column = (yylsp - 1)->last_column;
        yylsp->text = 0;
    }
    else
    {
        yylsp->last_line = (yylsp + yylen - 1)->last_line;
        yylsp->last_column = (yylsp + yylen - 1)->last_column;
    }
#endif

    /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

    yyn = yyr1[yyn];

    yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
    if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
        yystate = yytable[yystate];
    else
        yystate = yydefgoto[yyn - YYNTBASE];

    YYGOTO(yynewstate);

    YYLABEL(yyerrlab) /* here on detecting error */

    if (!yyerrstatus)
    /* If not already recovering from an error, report this error.  */
    {
        ++YY_Parser_NERRS;

#ifdef YY_Parser_ERROR_VERBOSE
        yyn = yypact[yystate];

        if (yyn > YYFLAG && yyn < YYLAST)
        {
            int size = 0;
            char *msg;
            int x, count;

            count = 0;
            /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
            for (x = (yyn < 0 ? -yyn : 0);
                 x < (sizeof(yytname) / sizeof(char *)); x++)
                if (yycheck[x + yyn] == x)
                    size += strlen(yytname[x]) + 15, count++;
            msg = (char *)malloc(size + 15);
            if (msg != 0)
            {
                strcpy(msg, "parse error");

                if (count < 5)
                {
                    count = 0;
                    for (x = (yyn < 0 ? -yyn : 0);
                         x < (sizeof(yytname) / sizeof(char *)); x++)
                        if (yycheck[x + yyn] == x)
                        {
                            strcat(msg, count == 0 ? ", expecting `" : " or `");
                            strcat(msg, yytname[x]);
                            strcat(msg, "'");
                            count++;
                        }
                }
                YY_Parser_ERROR(msg);
                free(msg);
            }
            else
                YY_Parser_ERROR("parse error; also virtual memory exceeded");
        }
        else
#endif /* YY_Parser_ERROR_VERBOSE */
            YY_Parser_ERROR("parse error");
    }

    YYGOTO(yyerrlab1);
    YYLABEL(yyerrlab1) /* here on error raised explicitly by an action */

    if (yyerrstatus == 3)
    {
        /* if just tried and failed to reuse lookahead token after an error, discard it.  */

        /* return failure if at end of input */
        if (YY_Parser_CHAR == YYEOF)
            YYABORT;

#if YY_Parser_DEBUG != 0
        if (YY_Parser_DEBUG_FLAG)
            fprintf(stderr, "Discarding token %d (%s).\n", YY_Parser_CHAR, yytname[yychar1]);
#endif

        YY_Parser_CHAR = YYEMPTY;
    }

    /* Else will try to reuse lookahead token
     after shifting the error token.  */

    yyerrstatus = 3; /* Each real token shifted decrements this */

    YYGOTO(yyerrhandle);

    YYLABEL(yyerrdefault) /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (yyn) YYGOTO(yydefault);
#endif

    YYLABEL(yyerrpop) /* pop the current state because it cannot handle the error token */

    if (yyssp == yyss)
        YYABORT;
    yyvsp--;
    yystate = *--yyssp;
#ifdef YY_Parser_LSP_NEEDED
    yylsp--;
#endif

#if YY_Parser_DEBUG != 0
    if (YY_Parser_DEBUG_FLAG)
    {
        short *ssp1 = yyss - 1;
        fprintf(stderr, "Error: state stack now");
        while (ssp1 != yyssp)
            fprintf(stderr, " %d", *++ssp1);
        fprintf(stderr, "\n");
    }
#endif

    YYLABEL(yyerrhandle)

    yyn = yypact[yystate];
    if (yyn == YYFLAG)
        YYGOTO(yyerrdefault);

    yyn += YYTERROR;
    if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
        YYGOTO(yyerrdefault);

    yyn = yytable[yyn];
    if (yyn < 0)
    {
        if (yyn == YYFLAG)
            YYGOTO(yyerrpop);
        yyn = -yyn;
        YYGOTO(yyreduce);
    }
    else if (yyn == 0)
        YYGOTO(yyerrpop);

    if (yyn == YYFINAL)
        YYACCEPT;

#if YY_Parser_DEBUG != 0
    if (YY_Parser_DEBUG_FLAG)
        fprintf(stderr, "Shifting error token, ");
#endif

    *++yyvsp = YY_Parser_LVAL;
#ifdef YY_Parser_LSP_NEEDED
    *++yylsp = YY_Parser_LLOC;
#endif

    yystate = yyn;
    YYGOTO(yynewstate);
    /* end loop, in which YYGOTO may be used. */
    YYENDGOTO
}

/* END */

#line 1038 "/home/clearcase/extern_libs/amd64/bison++/share/bison++/bison.cc"
#line 302 "dxreader.yacc"
